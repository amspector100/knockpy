<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>knockpy.metro &mdash; knockpy 1.3.4 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=e358f374"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            knockpy
          </a>
              <div class="version">
                1.3.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mrcknock.html">MRC Knockoffs Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apiref.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">knockpy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">knockpy.metro</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for knockpy.metro</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The metropolized knockoff sampler for an arbitrary probability density</span>
<span class="sd">and graphical structure using covariance-guided proposals.</span>

<span class="sd">See https://arxiv.org/abs/1903.00434 for a description of the algorithm</span>
<span class="sd">and proof of validity and runtime.</span>

<span class="sd">This code was based on initial code written by Stephen Bates in October</span>
<span class="sd">2019, which was released in combination with https://arxiv.org/abs/1903.00434.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># The basics</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="c1"># Logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="c1"># Network and UGM tools</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">scipy.special</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms.approximation</span> <span class="kn">import</span> <span class="n">treewidth</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">constants</span><span class="p">,</span> <span class="n">dgp</span><span class="p">,</span> <span class="n">smatrix</span><span class="p">,</span> <span class="n">utilities</span>
<span class="kn">from</span> <span class="nn">.knockoffs</span> <span class="kn">import</span> <span class="n">KnockoffSampler</span>


<div class="viewcode-block" id="gaussian_log_likelihood">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.gaussian_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">gaussian_log_likelihood</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Somehow this is faster than scipy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">mu</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">var</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">var</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="t_log_likelihood">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.t_log_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">t_log_likelihood</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">df_t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    UNNORMALIZED t loglikelihood.</span>
<span class="sd">    This is also faster than scipy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">df_t</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">result</span> <span class="o">*</span> <span class="p">(</span><span class="n">df_t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="get_ordering">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.get_ordering">[docs]</a>
<span class="k">def</span> <span class="nf">get_ordering</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a junction tree and returns a variable ordering for the metro</span>
<span class="sd">    knockoff sampler. The code from this function is adapted from</span>
<span class="sd">    the code distributed with https://arxiv.org/abs/1903.00434.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    T : A networkx graph that is a junction tree.</span>
<span class="sd">    Nodes must be sets with elements 0,...,p-1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order : a numpy array with unique elements 0,...,p-1</span>
<span class="sd">    active_frontier : list of lists</span>
<span class="sd">        a list of length p gwhere entry j is the set of entries &gt; j</span>
<span class="sd">        that are in V_j. This specifies the conditional independence structure</span>
<span class="sd">        of a joint covariate distribution. See page 34 of</span>
<span class="sd">        https://arxiv.org/abs/1903.00434.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">active_frontier</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">T</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Loop through leaf nodes</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">active_node</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

        <span class="c1"># Parent nodes of leaf nodes</span>
        <span class="c1"># active_vars get added to the order in this step</span>
        <span class="c1"># activated set are just the variables in the active node</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">active_node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">active_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">active_node</span><span class="p">)</span>
            <span class="n">activated_set</span> <span class="o">=</span> <span class="n">active_vars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">active_node</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">activated_set</span> <span class="o">=</span> <span class="n">active_vars</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">active_vars</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># This line was changed too</span>
            <span class="n">order</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">frontier</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">activated_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">order</span><span class="p">)))</span>
            <span class="n">active_frontier</span> <span class="o">+=</span> <span class="p">[</span><span class="n">frontier</span><span class="p">]</span>
        <span class="n">T</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">active_node</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">order</span><span class="p">),</span> <span class="n">active_frontier</span><span class="p">]</span></div>



<div class="viewcode-block" id="MetropolizedKnockoffSampler">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler">[docs]</a>
<span class="k">class</span> <span class="nc">MetropolizedKnockoffSampler</span><span class="p">(</span><span class="n">KnockoffSampler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metropolized knockoff sampler for arbitrary random variables</span>
<span class="sd">    using covariance-guided proposals.</span>

<span class="sd">    Group knockoffs are not yet supported.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lf : function</span>
<span class="sd">        log-probability density. This function should take a ``(n, p)``-shaped</span>
<span class="sd">        numpy array (n independent samples of a p-dimensional vector) and return</span>
<span class="sd">        a ``(n,)`` shaped array of log-probabilities. This can also be supplied</span>
<span class="sd">        as ``None`` if cliques and log-potentials are supplied.</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        the ``(n, p)``-shaped design matrix</span>
<span class="sd">    Xk : np.ndarray</span>
<span class="sd">        the ``(n, p)``-shaped matrix of knockoffs</span>
<span class="sd">    mu : np.ndarray</span>
<span class="sd">        The (estimated) mean of X. Exact FDR control is maintained</span>
<span class="sd">        even when this vector is incorrect. Defaults to the mean of X,</span>
<span class="sd">        e.g., ``X.mean(axis=0)``.</span>
<span class="sd">    Sigma : np.ndarray</span>
<span class="sd">        ``(p, p)``-shaped covariance matrix of the features. If ``None``, this</span>
<span class="sd">        is estimated using the data using a naive method to ensure compatability</span>
<span class="sd">        with the proposals. Exact FDR control is maintained even when Sigma</span>
<span class="sd">        is incorrect.</span>
<span class="sd">    undir_graph : np.ndarray or nx.Graph</span>
<span class="sd">        An undirected graph specifying the conditional independence</span>
<span class="sd">        structure of the data-generating process. This must be specified</span>
<span class="sd">        if either of the ``order`` or ``active_frontier`` params</span>
<span class="sd">        are not specified. One of two options:</span>
<span class="sd">        - A networkx undirected graph object</span>
<span class="sd">        - A ``(p, p)``-shaped numpy array, where nonzero elements represent edges.</span>
<span class="sd">    order : np.ndarray</span>
<span class="sd">        A ``p``-length numpy array specifying the ordering to sample the variables.</span>
<span class="sd">        Should be a vector with unique entries 0,...,p-1.</span>
<span class="sd">    active_fontier : A list of lists of length p where entry j is the set of</span>
<span class="sd">        entries &gt; j that are in V_j. This specifies the conditional independence</span>
<span class="sd">        structure of the distribution given by lf. See page 34 of the paper.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        A tuning parameter to increase / decrease the acceptance ratio.</span>
<span class="sd">        See appendix F.2. Defaults to 0.999.</span>
<span class="sd">    buckets : np.ndarray or list</span>
<span class="sd">        A list or array of discrete values that X can take.</span>
<span class="sd">        Covariance-guided proposals will be rounded to these values.</span>
<span class="sd">        If ``None``, Metro assumes the domain of each feature is all</span>
<span class="sd">        real numbers.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        kwargs to pass to the ``smatrix.compute_smatrix`` method for</span>
<span class="sd">        sampling proposals.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    order : np.ndarray</span>
<span class="sd">        ``(p,)``-shaped array of indices which reorders ``X`` into the</span>
<span class="sd">        order for sampling knockoffs.</span>
<span class="sd">    inv_order : np.ndarray</span>
<span class="sd">        ``(p,)``-shaped array of indices which takes a set of variables</span>
<span class="sd">        which have been reordered for metropolized sampling and returns</span>
<span class="sd">        them to their initial order. For example,</span>
<span class="sd">        ``X == X[:, self.order][:, self.inv_order]``.</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        ``(n, p)`` design matrix reordered according to the order for</span>
<span class="sd">        sampling knockoffs</span>
<span class="sd">    X_prop : np.ndarray</span>
<span class="sd">        ``(n, p)``-shaped array of knockoff proposals</span>
<span class="sd">    Xk : np.ndarray</span>
<span class="sd">        the ``(n, p)``-shaped array of knockoffs</span>
<span class="sd">    acceptances : np.ndarray</span>
<span class="sd">        a ``(n, p)``-shaped boolean array where ``acceptances[i, j] == 1``</span>
<span class="sd">        indicates that ``X_prop[i, j]`` was accepted.</span>
<span class="sd">    final_acc_probs : np.ndarray</span>
<span class="sd">        a ``(n, p)``-shaped array where ``final_acc_probs[i, j]`` is the</span>
<span class="sd">        acceptance probability for ``X_prop[i, j]``.</span>
<span class="sd">    Sigma : np.ndarray</span>
<span class="sd">        the ``(p, p)``-shaped estimated covariance matrix of ``X``. The</span>
<span class="sd">        class constructor guarantees this is compatible with the conditional</span>
<span class="sd">        independence structure of the data.</span>
<span class="sd">    S : np.ndarray</span>
<span class="sd">        the ``(p, p)``-shaped knockoff S-matrix used to generate the</span>
<span class="sd">        covariance-guided proposals.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All attributes of the MetropolizedKnockoffSampler are stored in the</span>
<span class="sd">    order that knockoffs are sampled, NOT the order that variables are</span>
<span class="sd">    initially passed in. For example, the ``X`` attribute will not necessarily</span>
<span class="sd">    equal the ``X`` argument: instead, ``self.X = X[:, self.order]``. To reorder</span>
<span class="sd">    attributes to the initial order of the ``X`` argument,</span>
<span class="sd">    use the syntax ``self.attribute[:, self.inv_order]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lf</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">Sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">undir_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">active_frontier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span>
        <span class="n">metro_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cliques</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">log_potentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buckets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Random params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span> <span class="o">=</span> <span class="n">metro_verbose</span>  <span class="c1"># Controls verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_queries</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Counts how many queries we make</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="n">buckets</span>

        <span class="c1"># Possibly estimate mean, cov matrix</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Sigma</span>  <span class="c1"># Improves readability slightly</span>
        <span class="n">cov_est</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">V</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_est</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">V</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">estimate_covariance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">shrinkage</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Possibly learn order / active frontier</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">active_frontier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">undir_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;If order OR active_frontier are not provided, you must specify the undir_graph&quot;</span>
                <span class="p">)</span>
            <span class="c1"># Convert to nx</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">undir_graph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">undir_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">undir_graph</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Run junction tree algorithm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">treewidth</span><span class="o">.</span><span class="n">treewidth_decomp</span><span class="p">(</span><span class="n">undir_graph</span><span class="p">)</span>
            <span class="n">order</span><span class="p">,</span> <span class="n">active_frontier</span> <span class="o">=</span> <span class="n">get_ordering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Undirected graph must be existent in this case</span>
        <span class="k">if</span> <span class="s2">&quot;invSigma&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invSigma&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is more numerically stable for super sparse Q</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">undir_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">undir_graph</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Handle case where the graph is entirely dense</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cov_est</span><span class="p">:</span>
                <span class="n">max_nonedge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">max_nonedge</span> <span class="o">&gt;</span> <span class="mf">1e-2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Precision matrix Q is not compatible with undirected graph (nonedge has value </span><span class="si">{</span><span class="n">max_nonedge</span><span class="si">}</span><span class="s2">); naively forcing values to zero&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="n">cov_est</span><span class="p">:</span>
                <span class="n">Q</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">chol2inv</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

        <span class="c1"># Save order and inverse order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># Re-order the variables: the log-likelihood</span>
        <span class="c1"># function (lf) is reordered in a separate method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unordered_lf</span> <span class="o">=</span> <span class="n">lf</span>

        <span class="c1"># Re-order the cliques</span>
        <span class="c1"># (internal order, not external order)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span> <span class="o">=</span> <span class="n">log_potentials</span>
        <span class="k">if</span> <span class="n">cliques</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">cliques</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">[</span><span class="n">clique</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create clique dictionaries. This maps variable i</span>
        <span class="c1"># to a list of two-length tuples.</span>
        <span class="c1">#   - The first element is the clique_key, which can</span>
        <span class="c1">#     be used to index into log_potentials.</span>
        <span class="c1">#   - The second element is the actual clique.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cliques</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">clique</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Re-order active frontier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span> <span class="o">+=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">active_frontier</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>

        <span class="c1"># Re-order mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># If mu == 0, then we can save lots of time</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zero_mu_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zero_mu_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Re-order sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">]</span>

        <span class="c1"># Possibly reorder S if it&#39;s in kwargs</span>
        <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">]</span>

        <span class="c1"># Create proposal parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_proposal_params</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="MetropolizedKnockoffSampler.lf_ratio">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.lf_ratio">[docs]</a>
    <span class="k">def</span> <span class="nf">lf_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Xjstar</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the log of the likelihood ratio</span>
<span class="sd">        between two observations: X where X[:,j]</span>
<span class="sd">        is replaced with Xjstar, divided by the likelihood</span>
<span class="sd">        of X. This is equivalent to (but often faster) than:</span>

<span class="sd">        &gt;&gt;&gt; ld_obs = self.lf(X)</span>
<span class="sd">        &gt;&gt;&gt; Xnew = X.copy()</span>
<span class="sd">        &gt;&gt;&gt; Xnew[:, j] = Xjstar</span>
<span class="sd">        &gt;&gt;&gt; ld_prop = self.lf(Xnew)</span>
<span class="sd">        &gt;&gt;&gt; ld_ratio = ld_prop - ld_obs</span>

<span class="sd">        When node potentials have been passed, this is much faster</span>
<span class="sd">        than calculating the log-likelihood function and subtracting.</span>

<span class="sd">        :param X: a n x p matrix of observations</span>
<span class="sd">        :param Xjstar: New observations for column j of X</span>
<span class="sd">        :param j: an int between 0 and p - 1, telling us which column to replace</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Just return the difference in lf if we don&#39;t have</span>
        <span class="c1"># access to cliques</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Log-likelihood 1</span>
            <span class="n">ld_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="c1"># New likelihood with Xjstar</span>
            <span class="n">Xnew</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Xnew</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xjstar</span>
            <span class="n">ld_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf</span><span class="p">(</span><span class="n">Xnew</span><span class="p">)</span>
            <span class="n">ld_ratio</span> <span class="o">=</span> <span class="n">ld_prop</span> <span class="o">-</span> <span class="n">ld_obs</span>

        <span class="c1"># If we have access to cliques, we can just compute log-potentials</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cliques</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ld_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Loop through cliques</span>
            <span class="k">for</span> <span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">cliques</span><span class="p">:</span>
                <span class="c1"># print(f&quot;At clique_key {clique_key},clique {clique}, j={j}&quot;)</span>
                <span class="c1"># print(f&quot;Orig clique is {self.order[clique]}&quot;)</span>
                <span class="n">orig_clique</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">clique</span><span class="p">]</span>  <span class="c1"># Original ordering</span>

                <span class="c1"># Clique representation(s) of X</span>
                <span class="n">Xc</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">clique</span><span class="p">]</span>
                <span class="n">Xcstar</span> <span class="o">=</span> <span class="n">Xc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Which index corresponds to index j in the clique</span>
                <span class="n">new_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">orig_clique</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Xcstar</span><span class="p">[:,</span> <span class="n">new_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xjstar</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Calculate log_potential difference</span>
                <span class="n">ld_ratio</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span><span class="p">[</span><span class="n">clique_key</span><span class="p">](</span><span class="n">Xcstar</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ld_ratio</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span><span class="p">[</span><span class="n">clique_key</span><span class="p">](</span><span class="n">Xc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ld_ratio</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.lf">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.lf">[docs]</a>
    <span class="k">def</span> <span class="nf">lf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reordered likelihood function&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unordered_lf</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">])</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.center">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.center">[docs]</a>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">active_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers an n x j matrix M. For mu = 0, does not perform</span>
<span class="sd">        this computation, which actually is a bottleneck</span>
<span class="sd">        for large n and p.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_mu_flag</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span>
        <span class="k">elif</span> <span class="n">active_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[:,</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">]</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.create_proposal_params">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.create_proposal_params">[docs]</a>
    <span class="k">def</span> <span class="nf">create_proposal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the covariance-guided proposal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            kwargs for the ``smatrix.compute_smatrix`` function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find the optimal S matrix. In general, we should set a</span>
        <span class="c1"># fairly high tolerance to avoid numerical errors.</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">&quot;tol&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">METRO_TOL</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">smatrix</span><span class="o">.</span><span class="n">compute_smatrix</span><span class="p">(</span><span class="n">Sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">]),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">]),</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invG</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># We don&#39;t compute this unless we have to later</span>

        <span class="c1"># Check for PSD-ness</span>
        <span class="n">minSeig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">))</span>
        <span class="n">min2VSeig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">minSeig</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum eigenvalue of S is </span><span class="si">{</span><span class="n">minSeig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min2VSeig</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Minimum eigenvalue of 2 Sigma - S is </span><span class="si">{</span><span class="n">min2VSeig</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum eigenvalue of S is </span><span class="si">{</span><span class="n">minSeig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum eigenvalue 2V-S is </span><span class="si">{</span><span class="n">min2VSeig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Efficiently calculate p inverses of subsets</span>
        <span class="c1"># of feature-knockoff covariance matrix.</span>
        <span class="c1"># This uses Cholesky decompositions for numerical</span>
        <span class="c1"># stability</span>
        <span class="c1"># Cholesky decomposition of Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invSigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>

        <span class="c1"># Suppose X sim N(mu, Sigma) and we have proposals X_{1:j-1}star</span>
        <span class="c1"># Then the conditional mean of the proposal Xjstar</span>
        <span class="c1"># is muj + mean_transform @ [X - mu, X_{1:j-1}^* - mu_{1:j-1}]</span>
        <span class="c1"># where the brackets [] denote vector concatenation.</span>
        <span class="c1"># This code calculates those mean transforms and the</span>
        <span class="c1"># conditional variances.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Possibly log</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metro starting to compute proposal parameters...&quot;</span><span class="p">)</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># Loop through and compute</span>
        <span class="c1"># j corresponds to the jth knockoff variable</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>  <span class="c1"># to avoid lint errors</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_iter</span><span class="p">:</span>
            <span class="c1"># G up to and excluding knockoff j</span>
            <span class="n">Gprej</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">Gprej</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># marginal corrs btwn knockoff j + others</span>
            <span class="n">sigma2prej</span> <span class="o">=</span> <span class="n">Gprej</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># 1. Compute inverse Sigma</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># At this point, we want L to be the cholesky</span>
                <span class="c1"># factor of Gprej, but it is the cholesky factor</span>
                <span class="c1"># of Gprej{j-1}. Therefore we perform a rank-1</span>
                <span class="c1"># update.</span>
                <span class="c1"># The c below is computed previously:</span>
                <span class="c1"># c = sp.linalg.solve_triangular(</span>
                <span class="c1">#   a=self.L, b=gammaprej, lower=True</span>
                <span class="c1"># )</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma2prej</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

                <span class="c1"># Concatenate new row [c,d] to L</span>
                <span class="n">new_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="p">])])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">new_row</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Check for numerical instabilities</span>
            <span class="c1"># diff = Gprej - np.dot(self.L, self.L.T)</span>
            <span class="c1"># max_error = np.max(np.abs(diff))</span>
            <span class="c1"># if max_error &gt; 10 * initial_error:</span>
            <span class="c1">#     # Correct</span>
            <span class="c1">#     print(</span>
            <span class="c1">#         f&quot;Maximum error is {max_error} &gt; 10x init error, recomputing L for p={self.p}, j={j}&quot;</span>
            <span class="c1">#     )</span>
            <span class="c1">#     self.L = np.linalg.cholesky(Gprej)</span>

            <span class="c1"># 2. Compute conditional variance</span>
            <span class="c1"># This subset of G includes knockoff j</span>
            <span class="n">Ginclj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">gammainclj</span> <span class="o">=</span> <span class="n">Ginclj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># marginal corrs btwn knockoff j + others</span>
            <span class="n">marg_var</span> <span class="o">=</span> <span class="n">Ginclj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Cholesky trick: Sigma[j,j] - ||c||_2^2</span>
            <span class="c1"># is the conditional variance</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">gammainclj</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">marg_var</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="c1"># Sanity check</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;This is likely a numerical error --- try increasing the tol kwarg.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cond_vars[</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2"> &lt; 0. </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">marg_var</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cond_vars[</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">]=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2"> &gt; marginal variance </span><span class="si">{</span><span class="n">marg_var</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Mean transform</span>
            <span class="n">mean_transform</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_transform</span><span class="p">)</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.fetch_S">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.fetch_S">[docs]</a>
    <span class="k">def</span> <span class="nf">fetch_S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">]</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.fetch_proposal_params">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.fetch_proposal_params">[docs]</a>
    <span class="k">def</span> <span class="nf">fetch_proposal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">prev_proposals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns mean and variance of proposal j given X and</span>
<span class="sd">        previous proposals. Both ``X`` and ``prev_proposals``</span>
<span class="sd">        must be in the order used to sample knockoff variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Infer j from prev_proposals</span>
        <span class="k">if</span> <span class="n">prev_proposals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">prev_proposals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># First p coordinates of cond_mean</span>
        <span class="c1"># X is n x p</span>
        <span class="c1"># self.mu is 1 x p</span>
        <span class="c1"># self.mean_transforms[j] is 1 x p + j</span>
        <span class="c1"># However, this cond mean only depends on</span>
        <span class="c1"># the active variables + [0:j], so to save</span>
        <span class="c1"># computation, we only compute that dot</span>
        <span class="n">active_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">cond_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">],</span> <span class="n">active_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="n">active_inds</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Second p coordinates of cond_mean</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># prev_proposals is n x j</span>
            <span class="c1"># self.mean_transforms[j] is 1 x p + j</span>
            <span class="c1"># self.mu is 1 x p</span>
            <span class="n">cond_mean2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">prev_proposals</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="c1"># Add together</span>
            <span class="n">cond_mean</span> <span class="o">+=</span> <span class="n">cond_mean2</span>

        <span class="c1"># Shift and return</span>
        <span class="n">cond_mean</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cond_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.fetch_cached_proposal_params">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.fetch_cached_proposal_params">[docs]</a>
    <span class="k">def</span> <span class="nf">fetch_cached_proposal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xtemp</span><span class="p">,</span> <span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above, but uses caching to speed up computation.</span>
<span class="sd">        This caching can be cheap (if self.cache is False) or</span>
<span class="sd">        extremely expensive (if self.cache is True) in terms of</span>
<span class="sd">        memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Conditional mean only depends on these inds</span>
        <span class="n">active_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># Calculate conditional means from precomputed products</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">cond_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">x_flags</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_prop</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_obs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">active_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">cond_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">Xtemp</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">],</span> <span class="n">active_inds</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="n">active_inds</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Add the effect of conditioning on the proposals</span>
        <span class="n">cond_mean</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_proposals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cond_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.q_ll">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.q_ll">[docs]</a>
    <span class="k">def</span> <span class="nf">q_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xjstar</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">prev_proposals</span><span class="p">,</span> <span class="n">cond_mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cond_var</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the log-likelihood of a proposal Xjstar given X</span>
<span class="sd">        and the previous proposals.</span>
<span class="sd">        Xjstar : np.ndarray</span>
<span class="sd">            ``(n,)``-shaped numpy array of values to evaluate the proposal</span>
<span class="sd">            likelihood at.</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            ``(n, p)``-shaped array of observed data, in the order used to</span>
<span class="sd">            sample knockoff variables.</span>
<span class="sd">        prev_proposals : np.ndarray</span>
<span class="sd">            ``(n, j-1)``-shaped array of previous proposals, in the order</span>
<span class="sd">            used to sample knockoff variables. If None, assumes j = 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cond_mean</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cond_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond_mean</span><span class="p">,</span> <span class="n">cond_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_proposal_params</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">prev_proposals</span><span class="o">=</span><span class="n">prev_proposals</span>
            <span class="p">)</span>
        <span class="c1"># Continuous case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gaussian_log_likelihood</span><span class="p">(</span><span class="n">Xjstar</span><span class="p">,</span> <span class="n">cond_mean</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">cond_var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bucket_probs</span> <span class="o">=</span> <span class="n">gaussian_log_likelihood</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">cond_mean</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bucket_log_probs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span>
                <span class="n">bucket_probs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">Xjstar</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">bucket_log_probs</span><span class="p">[</span><span class="n">flags</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.sample_proposals">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.sample_proposals">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_proposals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">,</span>
        <span class="n">prev_proposals</span><span class="p">,</span>
        <span class="n">cond_mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cond_var</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples a continuous or discrete proposal given the design</span>
<span class="sd">        matrix and the previous proposals. Can pass in the conditional</span>
<span class="sd">        mean and variance of the new proposals, if cached, to save</span>
<span class="sd">        computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These will be compatible as long as Sigma is</span>
        <span class="k">if</span> <span class="n">cond_mean</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cond_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond_mean</span><span class="p">,</span> <span class="n">cond_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_proposal_params</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">prev_proposals</span><span class="o">=</span><span class="n">prev_proposals</span>
            <span class="p">)</span>
        <span class="c1"># Continuous sampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cond_var</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">cond_mean</span>

        <span class="c1"># Discrete sampling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Cumulative probability buckets</span>
            <span class="n">bucket_probs</span> <span class="o">=</span> <span class="n">gaussian_log_likelihood</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="p">,</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">cond_mean</span><span class="p">,</span>
                <span class="n">var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bucket_probs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span>
                <span class="n">bucket_probs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">cuml_bucket_probs</span> <span class="o">=</span> <span class="n">bucket_probs</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Sample independently n times from buckets</span>
            <span class="n">unifs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cuml_bucket_probs</span> <span class="o">&lt;</span> <span class="n">unifs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">proposal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches key for dp dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># list(set(self.active_frontier[j]).union(set([j])))</span>
        <span class="n">arr_key</span> <span class="o">=</span> <span class="n">x_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inds</span><span class="p">]</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr_key</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_key2bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a key from dp dicts</span>
<span class="sd">        and turns it back into a boolean array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_Xtemp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a n x p array Xtemp which effectively does:</span>
<span class="sd">        Xtemp = self.X.copy()</span>
<span class="sd">        Xtemp[x_flags == 1] = self.X_prop[x_flags == 1].copy()</span>

<span class="sd">        TODO: make this so it copies less. This may require</span>
<span class="sd">        C code.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Informative error</span>
        <span class="k">if</span> <span class="n">x_flags</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;x flags are </span><span class="si">{</span><span class="n">x_flags</span><span class="si">}</span><span class="s2"> for j=</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">, strange because they should be zero before j&quot;</span>
            <span class="p">)</span>

        <span class="n">Xtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Xtemp</span>

<div class="viewcode-block" id="MetropolizedKnockoffSampler.log_q12">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.log_q12">[docs]</a>
    <span class="k">def</span> <span class="nf">log_q12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes q1 and q2 as specified by page 33 of the paper.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Temporary vector of Xs for query</span>
        <span class="n">Xtemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_Xtemp</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># Precompute cond_means for log_q2</span>
        <span class="n">cond_mean2</span><span class="p">,</span> <span class="n">cond_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_cached_proposal_params</span><span class="p">(</span>
            <span class="n">Xtemp</span><span class="o">=</span><span class="n">Xtemp</span><span class="p">,</span>
            <span class="n">x_flags</span><span class="o">=</span><span class="n">x_flags</span><span class="p">,</span>
            <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Adjust cond_mean for q1</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">Xtemp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">adjustment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="n">cond_mean1</span> <span class="o">=</span> <span class="n">cond_mean2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">adjustment</span>

        <span class="c1">### Continuous case</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># q2 is:</span>
            <span class="c1"># Pr(Xjstar = xjstar | X = Xtemp, tildeX_{1:j-1}, Xstar_{1:j-1})</span>
            <span class="n">log_q2</span> <span class="o">=</span> <span class="n">gaussian_log_likelihood</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">cond_mean2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># q1 is:</span>
            <span class="c1"># Pr(Xjstar = Xtemp[j] | Xj = xjstar, X_{-j} = X_temp_{-j}, tildeX_{1:j-1}, Xstar_{1:j-1})</span>
            <span class="n">log_q1</span> <span class="o">=</span> <span class="n">gaussian_log_likelihood</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="n">Xtemp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">cond_mean1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Terms are same as before</span>
            <span class="n">log_q2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_ll</span><span class="p">(</span>
                <span class="n">Xjstar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">prev_proposals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">cond_mean</span><span class="o">=</span><span class="n">cond_mean2</span><span class="p">,</span>
                <span class="n">cond_var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">log_q1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_ll</span><span class="p">(</span>
                <span class="n">Xjstar</span><span class="o">=</span><span class="n">Xtemp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">prev_proposals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">cond_mean</span><span class="o">=</span><span class="n">cond_mean1</span><span class="p">,</span>
                <span class="n">cond_var</span><span class="o">=</span><span class="n">cond_var</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">log_q1</span><span class="p">,</span> <span class="n">log_q2</span><span class="p">,</span> <span class="n">Xtemp</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.compute_F">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.compute_F">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the F function from Page 33 pf the paper:</span>
<span class="sd">        Pr(tildeXj=tildexj, Xjstar=xjstar | Xtemp, tildeX_{1:j-1}, Xjstar_{1:j-1})</span>
<span class="sd">        Note that tildexj and xjstar are NOT inputs because they do NOT change</span>
<span class="sd">        during the junction tree DP process.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get key, possibly return cached result</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F_queries</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># q1/q2 terms</span>
        <span class="n">log_q1</span><span class="p">,</span> <span class="n">log_q2</span><span class="p">,</span> <span class="n">Xtemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_q12</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># Acceptance mask and probabilities: note that</span>
        <span class="c1"># the flag for accepting / rejecting comes from the</span>
        <span class="c1"># TRUE knockoffs (e.g. self.acceptances)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">acc_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Pass extra parameters to avoid repeating computation</span>
            <span class="n">acc_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_acc_prob</span><span class="p">(</span>
                <span class="n">x_flags</span><span class="o">=</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">log_q1</span><span class="o">=</span><span class="n">log_q1</span><span class="p">,</span> <span class="n">log_q2</span><span class="o">=</span><span class="n">log_q2</span><span class="p">,</span> <span class="n">Xtemp</span><span class="o">=</span><span class="n">Xtemp</span>
            <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">log_q2</span> <span class="o">+</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">acc_probs</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mask</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">acc_probs</span><span class="p">)</span>

        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.compute_acc_prob">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.compute_acc_prob">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_acc_prob</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_flags</span><span class="p">,</span>
        <span class="n">j</span><span class="p">,</span>
        <span class="n">log_q1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">log_q2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">Xtemp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes acceptance probability for variable ``j``</span>
<span class="sd">        given a particular rejection pattern ``x_flags``.</span>

<span class="sd">        Mathematically, this is:</span>
<span class="sd">        Pr(tildeXj = Xjstar | Xtemp, Xtilde_{1:j-1}, Xstar_{1:j})</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get key, possibly return cached result</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># 1. q1, q2 ratio</span>
        <span class="k">if</span> <span class="n">log_q1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">log_q2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log_q1</span><span class="p">,</span> <span class="n">log_q2</span><span class="p">,</span> <span class="n">Xtemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_q12</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">lq_ratio</span> <span class="o">=</span> <span class="n">log_q1</span> <span class="o">-</span> <span class="n">log_q2</span>

        <span class="c1"># Possibly ceate X temp variable</span>
        <span class="k">if</span> <span class="n">Xtemp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Xtemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_Xtemp</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="c1"># 2. Density ratio</span>
        <span class="n">ld_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lf_ratio</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">Xtemp</span><span class="p">,</span>
            <span class="n">Xjstar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
            <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># # a. According to pattern</span>
        <span class="c1"># ld_obs = self.lf(Xtemp)</span>
        <span class="c1"># # b. When Xj is not observed</span>
        <span class="c1"># Xtemp_prop = Xtemp.copy()</span>
        <span class="c1"># Xtemp_prop[:, j] = self.X_prop[:, j]</span>
        <span class="c1"># ld_prop = self.lf(Xtemp_prop)</span>
        <span class="c1"># ld_ratio = ld_prop - ld_obs</span>

        <span class="c1"># Delete to save memory</span>
        <span class="k">del</span> <span class="n">Xtemp</span>

        <span class="c1"># 3. Calc ln(Fk ratios) for k &lt; j. These should be 0 except</span>
        <span class="c1"># when k &lt; j and j in Vk, which is why we loop through</span>
        <span class="c1"># affected variables.</span>
        <span class="c1"># Numerator for these ratios use different flags</span>
        <span class="n">Fj_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">x_flags_num</span> <span class="o">=</span> <span class="n">x_flags</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x_flags_num</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Loop through</span>
        <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">affected_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="c1"># Numerator</span>
            <span class="n">num_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">(</span><span class="n">x_flags_num</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j2</span><span class="p">]:</span>
                <span class="n">Fj2_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j2</span><span class="p">][</span><span class="n">num_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Fj2_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_F</span><span class="p">(</span><span class="n">x_flags_num</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span>

            <span class="c1"># Denominator uses same flags</span>
            <span class="n">denom_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">denom_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j2</span><span class="p">]:</span>
                <span class="n">Fj2_denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span><span class="p">[</span><span class="n">j2</span><span class="p">][</span><span class="n">denom_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Fj2_denom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_F</span><span class="p">(</span><span class="n">x_flags</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span>

            <span class="c1"># Add ratio to Fj_ratio</span>
            <span class="n">Fj_ratio</span> <span class="o">=</span> <span class="n">Fj_ratio</span> <span class="o">+</span> <span class="n">Fj2_num</span> <span class="o">-</span> <span class="n">Fj2_denom</span>

        <span class="c1"># Put it all together and multiply by gamma</span>
        <span class="c1"># Fast_exp function is helpful for profiling</span>
        <span class="c1"># (to see how much time is spent here)</span>
        <span class="k">def</span> <span class="nf">fast_exp</span><span class="p">(</span><span class="n">ld_ratio</span><span class="p">,</span> <span class="n">lq_ratio</span><span class="p">,</span> <span class="n">Fj_ratio</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ld_ratio</span> <span class="o">+</span> <span class="n">lq_ratio</span> <span class="o">+</span> <span class="n">Fj_ratio</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">MAXEXP32</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">acc_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fast_exp</span><span class="p">(</span><span class="n">ld_ratio</span><span class="p">,</span> <span class="n">lq_ratio</span><span class="p">,</span> <span class="n">Fj_ratio</span><span class="p">))</span>

        <span class="c1"># Clip to deal with floating point errors</span>
        <span class="n">acc_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">,</span> <span class="n">acc_prob</span><span class="p">))</span>

        <span class="c1"># Make sure the degenerate case has been computed</span>
        <span class="c1"># correctly</span>
        <span class="k">if</span> <span class="n">x_flags</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">acc_prob</span><span class="p">[</span><span class="n">x_flags</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;At step=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s2">, j=</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">, we have&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;acc_prob = </span><span class="si">{</span><span class="n">acc_prob</span><span class="si">}</span><span class="s2"> but x_flags[:, j]=</span><span class="si">{</span><span class="n">x_flags</span><span class="p">[:,</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;These accetance probs should be ~1&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Cache and return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc_prob</span>
        <span class="k">return</span> <span class="n">acc_prob</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.cache_conditional_proposal_params">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.cache_conditional_proposal_params">[docs]</a>
    <span class="k">def</span> <span class="nf">cache_conditional_proposal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expensive_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Caches some of the conditional means for Xjstar | Xtemp.</span>
<span class="sd">        If expensive_cache = True, this will be quite memory intensive</span>
<span class="sd">        in order to achieve a 2-3x speedup. Otherwise, achieves a</span>
<span class="sd">        a 20-30% speedup at a more modest memory cost.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cache conditional means</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metro beginning to cache conditional means...&quot;</span><span class="p">)</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># Precompute centerings</span>
        <span class="n">centX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">centX_prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_obs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_prop</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_proposals</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_iter</span><span class="p">:</span>
            <span class="c1"># We only need to store the coordinates along the active</span>
            <span class="c1"># inds which saves some memory</span>
            <span class="n">active_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># Cache some precomputed conditional means</span>
            <span class="c1"># a. Cache the effect of conditioning on Xstar = self.X_prop</span>
            <span class="c1"># This is very cheap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_proposals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># b/c: Possibly cache the effect of conditioning on X = self.X / self.X_prop</span>
            <span class="c1"># This is very memory intensive</span>
            <span class="k">if</span> <span class="n">expensive_cache</span><span class="p">:</span>
                <span class="c1"># a. Cache the effect of conditiong on X = self.X</span>
                <span class="n">cache_obs</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">centX</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">][:,</span> <span class="n">active_inds</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_obs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_obs</span>
                <span class="c1"># b. Cache the effect of conditioning on X = self.X_prop</span>
                <span class="n">cache_prop</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">centX_prop</span><span class="p">[:,</span> <span class="n">active_inds</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_transforms</span><span class="p">[</span><span class="n">j</span><span class="p">][:,</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">][:,</span> <span class="n">active_inds</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_prop</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_prop</span></div>


<div class="viewcode-block" id="MetropolizedKnockoffSampler.sample_knockoffs">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.MetropolizedKnockoffSampler.sample_knockoffs">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_knockoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples knockoffs using the metropolized knockoff</span>
<span class="sd">        sampler.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clip : float</span>
<span class="sd">            To provide numerical stability, we make the minimum</span>
<span class="sd">            acceptance probability clip. If ``clip=0``, some</span>
<span class="sd">            acceptance probabilities may become negative due to</span>
<span class="sd">            floating point errors.</span>
<span class="sd">        cache : bool</span>
<span class="sd">            If True, uses a very memory intensive caching system</span>
<span class="sd">            to get a 2-3x speedup when calculating conditional means</span>
<span class="sd">            for the proposals. Defaults to true if n * (p**2) &lt; 1e9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xk : np.ndarray</span>
<span class="sd">            A ``(n, p)``-shaped knockoff matrix in the original order</span>
<span class="sd">            the variables were passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Save clip constant for later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>
        <span class="n">num_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">num_params</span> <span class="o">&lt;</span> <span class="mf">1e9</span>

        <span class="c1"># Possibly log</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Metro will use memory expensive caching for 2-3x speedup, storing </span><span class="si">{</span><span class="n">num_params</span><span class="si">}</span><span class="s2"> params&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metro will not cache cond_means to save a lot of memory&quot;</span><span class="p">)</span>

        <span class="c1"># Dynamic programming approach: store acceptance probs</span>
        <span class="c1"># as well as Fj values (see page 33)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acc_dicts</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_dicts</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>

        <span class="c1"># Locate previous terms affected by variable j</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">affected_vars</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">j2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_frontier</span><span class="p">[</span><span class="n">j2</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">affected_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j2</span><span class="p">]</span>

        <span class="c1"># Store pattern of TRUE acceptances / rejections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>

        <span class="c1"># Proposals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Start to store knockoffs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Decide whether or not to log</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metro beginning to compute proposals...&quot;</span><span class="p">)</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># Loop across variables to sample proposals</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_iter</span><span class="p">:</span>
            <span class="c1"># Sample proposal</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_proposals</span><span class="p">(</span>
                <span class="n">X</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">prev_proposals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Cache the conditional proposal params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_conditional_proposal_params</span><span class="p">(</span>
            <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">,</span> <span class="n">expensive_cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="p">)</span>

        <span class="c1"># Loop across variables to compute acc ratios</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metro computing acceptance probabilities...&quot;</span><span class="p">)</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_iter</span><span class="p">:</span>
            <span class="c1"># Cache which knockoff we are sampling</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">j</span>

            <span class="c1"># Compute acceptance probability, which is an n-length vector</span>
            <span class="n">acc_prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_acc_prob</span><span class="p">(</span>
                <span class="n">x_flags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)),</span>
                <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">acc_prob</span>

            <span class="c1"># Sample to get actual acceptances</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc_prob</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># Store knockoffs</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_prop</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">][</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Delete cache to save memory</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metro_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting cache to save memory...&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_obs</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_mean_obs_eq_prop</span>

        <span class="c1"># Return re-sorted</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span><span class="p">]</span></div>
</div>



<span class="c1">### Knockoff Samplers for T-distributions</span>
<div class="viewcode-block" id="t_markov_loglike">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.t_markov_loglike">[docs]</a>
<span class="k">def</span> <span class="nf">t_markov_loglike</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rhos</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates log-likelihood for markov chain</span>
<span class="sd">    specified in https://arxiv.org/pdf/1903.00434.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">rhos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Shape of rhos </span><span class="si">{</span><span class="n">rhos</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match shape of X </span><span class="si">{</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">inv_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">df_t</span> <span class="o">/</span> <span class="p">(</span><span class="n">df_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Initial log-like for first variable</span>
    <span class="n">loglike</span> <span class="o">=</span> <span class="n">t_log_likelihood</span><span class="p">(</span><span class="n">inv_scale</span> <span class="o">*</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">df_t</span><span class="o">=</span><span class="n">df_t</span><span class="p">)</span>

    <span class="c1"># Differences: these are i.i.d. t</span>
    <span class="c1"># print(inv_scale * (X[:, 1:] - rhos * X[:, :-1]))</span>
    <span class="n">conjugates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rhos</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Zjs</span> <span class="o">=</span> <span class="n">inv_scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">rhos</span> <span class="o">*</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">conjugates</span>
    <span class="n">Zj_loglike</span> <span class="o">=</span> <span class="n">t_log_likelihood</span><span class="p">(</span><span class="n">Zjs</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="n">df_t</span><span class="p">)</span>

    <span class="c1"># Add log-likelihood for differences</span>
    <span class="k">return</span> <span class="n">loglike</span> <span class="o">+</span> <span class="n">Zj_loglike</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="ARTKSampler">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.ARTKSampler">[docs]</a>
<span class="k">class</span> <span class="nc">ARTKSampler</span><span class="p">(</span><span class="n">MetropolizedKnockoffSampler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples knockoffs for autoregressive T-distributed designs.</span>
<span class="sd">    (Hence, ARTK). See https://arxiv.org/pdf/1903.00434.pdf</span>
<span class="sd">    for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        the ``(n, p)``-shaped design matrix</span>
<span class="sd">    Sigma : np.ndarray</span>
<span class="sd">        ``(p, p)``-shaped covariance matrix of the features. The first</span>
<span class="sd">        diagonal should be the pairwise correlations which define the</span>
<span class="sd">        Markov chain.</span>
<span class="sd">    df_t : float</span>
<span class="sd">        The degrees of freedom for the t-distributions.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        kwargs to pass to the constructor method of the generic</span>
<span class="sd">        ``MetropolizedKnockoffSampler`` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">df_t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Rhos and graph</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_t</span> <span class="o">=</span> <span class="n">df_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">chol2inv</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

        <span class="c1"># Cliques and clique log-potentials - start</span>
        <span class="c1"># with initial clique. Note that a log-potential</span>
        <span class="c1"># for a clique of size k takes an array of size</span>
        <span class="c1"># n x k as an input.</span>
        <span class="n">cliques</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">log_potentials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inv_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">df_t</span> <span class="o">/</span> <span class="p">(</span><span class="n">df_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">log_potentials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">X0</span><span class="p">:</span> <span class="n">t_log_likelihood</span><span class="p">(</span><span class="n">inv_scale</span> <span class="o">*</span> <span class="n">X0</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="n">df_t</span><span class="p">))</span>

        <span class="c1"># Pairwise log-potentials</span>
        <span class="k">def</span> <span class="nf">make_t_logpotential</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">conj</span><span class="p">,</span> <span class="n">invscale</span><span class="p">,</span> <span class="n">df_t</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">lp</span><span class="p">(</span><span class="n">Xc</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t_log_likelihood</span><span class="p">(</span>
                    <span class="n">inv_scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">Xc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">Xc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">conj</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="n">df_t</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">lp</span>

        <span class="n">conjugates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">conj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="p">,</span> <span class="n">conjugates</span><span class="p">):</span>
            <span class="c1"># Append the clique: X[:, [i+1,i]]</span>
            <span class="n">cliques</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="c1"># Takes an n x 2 array as an input</span>
            <span class="n">log_potentials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_t_logpotential</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">conj</span><span class="p">,</span> <span class="n">inv_scale</span><span class="p">,</span> <span class="n">df_t</span><span class="p">))</span>

        <span class="c1"># Loss function (unordered)</span>
        <span class="k">def</span> <span class="nf">lf</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">t_markov_loglike</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_t</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">lf</span><span class="o">=</span><span class="n">lf</span><span class="p">,</span>
            <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
            <span class="n">mu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
            <span class="n">Sigma</span><span class="o">=</span><span class="n">V</span><span class="p">,</span>
            <span class="n">undir_graph</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">cliques</span><span class="o">=</span><span class="n">cliques</span><span class="p">,</span>
            <span class="n">log_potentials</span><span class="o">=</span><span class="n">log_potentials</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="t_mvn_loglike">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.t_mvn_loglike">[docs]</a>
<span class="k">def</span> <span class="nf">t_mvn_loglike</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">invScale</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates multivariate t log-likelihood</span>
<span class="sd">    up to normalizing constant.</span>
<span class="sd">    :param X: n x p array of data</span>
<span class="sd">    :param invScale: p x p array, inverse multivariate t scale matrix</span>
<span class="sd">    :param mu: p-length array, location parameter</span>
<span class="sd">    :param df_t: degrees of freedom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">invScale</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">mu</span>
    <span class="n">quad_form</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">invScale</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">log_quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">quad_form</span> <span class="o">/</span> <span class="n">df_t</span><span class="p">)</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">df_t</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">exponent</span> <span class="o">*</span> <span class="n">log_quad</span></div>



<div class="viewcode-block" id="BlockTSampler">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.BlockTSampler">[docs]</a>
<span class="k">class</span> <span class="nc">BlockTSampler</span><span class="p">(</span><span class="n">KnockoffSampler</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">df_t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples knockoffs for block multivariate t designs, where</span>
<span class="sd">        each block is independent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            the ``(n, p)``-shaped design matrix</span>
<span class="sd">        Sigma : np.ndarray</span>
<span class="sd">            ``(p, p)``-shaped covariance matrix of the features. This must</span>
<span class="sd">            be in block-diagonal form.</span>
<span class="sd">        df_t : float</span>
<span class="sd">            The degrees of freedom for the t-distributions.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            kwargs to pass to the constructor method of the generic</span>
<span class="sd">            ``MetropolizedKnockoffSampler`` class.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        samplers : list</span>
<span class="sd">            A list of ``MetropolizedKnockoffSampler`` objects used to sample</span>
<span class="sd">            knockoffs for each block.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike the attributes of a ``MetropolizedKnockoffSampler`` class,</span>
<span class="sd">        the attributes of a ``BlockTSampler`` class are stored in the same</span>
<span class="sd">        order that the design matrix is initially passed in. E.g., ``self.Xk``</span>
<span class="sd">        corresponds with ``self.X``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Discover &quot;block structure&quot; of T</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_inds</span> <span class="o">=</span> <span class="n">dgp</span><span class="o">.</span><span class="n">cov2blocks</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_t</span> <span class="o">=</span> <span class="n">df_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>

        <span class="c1"># Dummy order / inv_order variables for consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># Loop through blocks and initialize samplers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_inds</span><span class="p">):</span>
            <span class="c1"># Invert block and create scale matrix</span>
            <span class="n">inv_block</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">chol2inv</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">invScale</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">df_t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_block</span>

            <span class="c1"># Undir graph is all connected</span>
            <span class="n">blocksize</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">undir_graph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">blocksize</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">))</span>

            <span class="c1"># Initialize sampler</span>
            <span class="n">block_sampler</span> <span class="o">=</span> <span class="n">MetropolizedKnockoffSampler</span><span class="p">(</span>
                <span class="n">lf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">X</span><span class="p">:</span> <span class="n">t_mvn_loglike</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">invScale</span><span class="p">,</span> <span class="n">df_t</span><span class="o">=</span><span class="n">df_t</span><span class="p">),</span>
                <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">],</span>
                <span class="n">mu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">blocksize</span><span class="p">),</span>
                <span class="n">Sigma</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
                <span class="n">undir_graph</span><span class="o">=</span><span class="n">undir_graph</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">inv_order</span> <span class="o">=</span> <span class="n">block_sampler</span><span class="o">.</span><span class="n">inv_order</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_sampler</span><span class="o">.</span><span class="n">S</span><span class="p">[:,</span> <span class="n">inv_order</span><span class="p">][</span><span class="n">inv_order</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_sampler</span><span class="p">)</span>

        <span class="c1"># Concatenate S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>

<div class="viewcode-block" id="BlockTSampler.fetch_S">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.BlockTSampler.fetch_S">[docs]</a>
    <span class="k">def</span> <span class="nf">fetch_S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span></div>


<div class="viewcode-block" id="BlockTSampler.sample_knockoffs">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.BlockTSampler.sample_knockoffs">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_knockoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually samples knockoffs sequentially for each block.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            kwargs for the ``MetropolizedKnockoffSampler.sample_knockoffs``</span>
<span class="sd">            call for each block.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xk : np.ndarray</span>
<span class="sd">            A ``(n, p)``-shaped knockoff matrix in the original order</span>
<span class="sd">            the variables were passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Loop through blocks and sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">)):</span>
            <span class="c1"># Sample knockoffs</span>
            <span class="n">Xk_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sample_knockoffs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Xk_block</span><span class="p">)</span>

            <span class="c1"># Save final_acc_probs, acceptances</span>
            <span class="n">block_acc_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="p">[</span>
                <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">inv_order</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_acc_probs</span><span class="p">)</span>
            <span class="n">block_acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">inv_order</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_acc</span><span class="p">)</span>

        <span class="c1"># Concatenate + return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span></div>
</div>



<div class="viewcode-block" id="GibbsGridSampler">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.GibbsGridSampler">[docs]</a>
<span class="k">class</span> <span class="nc">GibbsGridSampler</span><span class="p">(</span><span class="n">KnockoffSampler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Samples knockoffs for a discrete gibbs grid using the divide-and-conquer</span>
<span class="sd">    algorithm plus metropolized knockoff sampling.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        the ``(n, p)``-shaped design matrix</span>
<span class="sd">    gibbs_graph : np.ndarray</span>
<span class="sd">        ``(p, p)``-shaped matrix specifying the distribution</span>
<span class="sd">        of the gibbs grid: see ``knockpy.dgp.sample_gibbs``.</span>
<span class="sd">        This must correspond to a grid-like undirected graphical</span>
<span class="sd">        model.</span>
<span class="sd">    Sigma : np.ndarray</span>
<span class="sd">        ``(p, p)``-shaped estimated covariance matrix of the data.</span>
<span class="sd">    max_width : int</span>
<span class="sd">        The maximum treewidth to allow in the divide-and-conquer</span>
<span class="sd">        algorithm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Unlike the attributes of a ``MetropolizedKnockoffSampler`` class,</span>
<span class="sd">    the attributes of a ``BlockTSampler`` class are stored in the same</span>
<span class="sd">    order that the design matrix is initially passed in. E.g., ``self.Xk``</span>
<span class="sd">    corresponds with ``self.X``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gibbs_graph</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Infer bucketization and V</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gibbs_graph</span> <span class="o">=</span> <span class="n">gibbs_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;p </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="si">}</span><span class="s2"> must be a square number for gibbs grid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buckets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Div and conquer makes this nontrivial</span>
        <span class="c1"># (Note to self: maybe TODO?)</span>
        <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;invSigma&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;invSigma&quot;</span><span class="p">)</span>

        <span class="c1"># Dummy order / inv_order variables for consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_ising_logpotential</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">lp</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">lp</span>

        <span class="c1"># Learn cliques, log-potentials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">gibbs_graph</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cliques</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">gibbs_graph</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_ising_logpotential</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="c1"># Maps variables to cliques they&#39;re part of</span>
        <span class="c1"># Clique key maps the clique back to the log-potential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cliques</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">clique</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span><span class="p">))</span>

        <span class="c1"># Split X up into blocks along the n-axis.</span>
        <span class="c1"># Each divconq key corresponds to one way to</span>
        <span class="c1"># divide/conquer the variables, and to one</span>
        <span class="c1"># of these blocks.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">div_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="p">[</span><span class="n">max_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">div_type</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">trans</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rand_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">rand_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_ninds</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rand_inds</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">X_ninds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Structure of self.divconq_info</span>
        <span class="c1"># (1) Dictionary takes a divide-and-conquery key</span>
        <span class="c1"># (translation + row/col)</span>
        <span class="c1"># (2) This maps to a list of dictionaries. Each</span>
        <span class="c1"># dictionary corresponds to one of the blocks</span>
        <span class="c1"># in the divide and conquer procedure.</span>
        <span class="c1"># (3) Each dictionary takes three keys: inds,</span>
        <span class="c1"># cliques, lps.</span>
        <span class="c1"># - inds is the list of ORIGINAL coordinates</span>
        <span class="c1"># of the block of variables. E.g. if block 1</span>
        <span class="c1"># corresponds to columns 1,5,6, in X,</span>
        <span class="c1"># then inds = [1,5,6]</span>
        <span class="c1"># - cliques is a list of cliques in the NEW coordinates</span>
        <span class="c1"># of the block. So for example, if 1,5 was a clique in</span>
        <span class="c1"># the prior example, then (0,1) would be in this list.</span>
        <span class="c1"># - lps are the log-potentials corresponding to</span>
        <span class="c1"># the cliques above.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divconq_info</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># This maps divconq key</span>
        <span class="c1"># to a list of separators (e.g. knockoffs = features)</span>
        <span class="c1"># for these indices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separators</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">dc_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">:</span>
            <span class="n">div_type</span> <span class="o">=</span> <span class="n">dc_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dc_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">seps</span><span class="p">,</span> <span class="n">dict_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_divide_variables</span><span class="p">(</span>
                <span class="n">dc_key</span><span class="o">=</span><span class="n">dc_key</span><span class="p">,</span>
                <span class="n">translation</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span>
                <span class="n">max_width</span><span class="o">=</span><span class="n">max_width</span><span class="p">,</span>
                <span class="n">div_type</span><span class="o">=</span><span class="n">div_type</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">[</span><span class="n">dc_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">seps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">divconq_info</span><span class="p">[</span><span class="n">dc_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_list</span>

        <span class="c1"># Initialize samplers. Each sampler will only sample</span>
        <span class="c1"># a subset of variables for a subset of the data</span>
        <span class="c1"># Structure: maps divconq key to list of n_inds, p_inds, sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">:</span>
            <span class="c1"># Fetch indicies</span>
            <span class="n">n_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_ninds</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">sep_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># Helper for conditional cov matrices</span>
            <span class="n">V11</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">sep_inds</span><span class="p">][:,</span> <span class="n">sep_inds</span><span class="p">]</span>  <span class="c1"># s x s</span>
            <span class="n">V11_inv</span> <span class="o">=</span> <span class="n">utilities</span><span class="o">.</span><span class="n">chol2inv</span><span class="p">(</span><span class="n">V11</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">div_group_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divconq_info</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">p_inds</span> <span class="o">=</span> <span class="n">div_group_dict</span><span class="p">[</span><span class="s2">&quot;inds&quot;</span><span class="p">]</span>

                <span class="c1"># Find conditional covariance matrix V</span>
                <span class="c1"># for p_inds given</span>
                <span class="c1"># the conditioned-on-separators</span>
                <span class="n">V22</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">p_inds</span><span class="p">][:,</span> <span class="n">p_inds</span><span class="p">]</span>  <span class="c1"># p_i x p_i</span>
                <span class="n">V21</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">p_inds</span><span class="p">][:,</span> <span class="n">sep_inds</span><span class="p">]</span>  <span class="c1"># p_i x s</span>
                <span class="n">Vcond</span> <span class="o">=</span> <span class="n">V22</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">V21</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">V11_inv</span><span class="p">,</span> <span class="n">V21</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="n">sampler</span> <span class="o">=</span> <span class="n">MetropolizedKnockoffSampler</span><span class="p">(</span>
                    <span class="n">lf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">[</span><span class="n">n_inds</span><span class="p">][:,</span> <span class="n">p_inds</span><span class="p">],</span>
                    <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">[</span><span class="n">p_inds</span><span class="p">],</span>
                    <span class="n">Sigma</span><span class="o">=</span><span class="n">Vcond</span><span class="p">,</span>
                    <span class="n">undir_graph</span><span class="o">=</span><span class="n">gibbs_graph</span><span class="p">[</span><span class="n">p_inds</span><span class="p">][:,</span> <span class="n">p_inds</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">cliques</span><span class="o">=</span><span class="n">div_group_dict</span><span class="p">[</span><span class="s2">&quot;cliques&quot;</span><span class="p">],</span>
                    <span class="n">log_potentials</span><span class="o">=</span><span class="n">div_group_dict</span><span class="p">[</span><span class="s2">&quot;lps&quot;</span><span class="p">],</span>
                    <span class="n">buckets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buckets</span><span class="p">,</span>
                    <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">sampler</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">max_width</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Treewidth heuristic inaccurate during divide/conquer, sampler for </span><span class="si">{</span><span class="n">p_inds</span><span class="si">}</span><span class="s2"> has width </span><span class="si">{</span><span class="n">sampler</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2"> &gt; max_width </span><span class="si">{</span><span class="n">max_width</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n_inds</span><span class="p">,</span> <span class="n">p_inds</span><span class="p">,</span> <span class="n">sampler</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">num2coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dgp</span><span class="o">.</span><span class="n">num2coords</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">gridwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">coords2num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">wc</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dgp</span><span class="o">.</span><span class="n">coords2num</span><span class="p">(</span><span class="n">lcoord</span><span class="o">=</span><span class="n">lc</span><span class="p">,</span> <span class="n">wcoord</span><span class="o">=</span><span class="n">wc</span><span class="p">,</span> <span class="n">gridwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">div_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for divide-and-conquer</span>
<span class="sd">        in Ising model. Extracts active coordinate</span>
<span class="sd">        from variable i.</span>
<span class="sd">        Returns ac, lc, wc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lc</span><span class="p">,</span> <span class="n">wc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num2coords</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">div_type</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lc</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">wc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wc</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">wc</span>

<div class="viewcode-block" id="GibbsGridSampler.fetch_S">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.GibbsGridSampler.fetch_S">[docs]</a>
    <span class="k">def</span> <span class="nf">fetch_S</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns ``None`` because the divide-and-conquer approach means</span>
<span class="sd">        there is no one S-matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GibbsGridSampler.sample_knockoffs">
<a class="viewcode-back" href="../../apiref.html#knockpy.metro.GibbsGridSampler.sample_knockoffs">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_knockoffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples knockoffs using divide-and-conquer approach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Keyword args for ``MetropolizedKnockoffSampler.sample_knockoffs``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Xk : np.ndarray</span>
<span class="sd">            A ``(n, p)``-shaped knockoff matrix in the original order</span>
<span class="sd">            the variables were passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Loop through different ways of separating variables</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_keys</span><span class="p">:</span>
            <span class="c1"># N inds for this particular method of separation</span>
            <span class="n">n_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_ninds</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

            <span class="c1"># Initialize output</span>
            <span class="n">Xkblock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">n_inds</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
            <span class="n">Xkblock</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">accblock</span> <span class="o">=</span> <span class="n">Xkblock</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">probblock</span> <span class="o">=</span> <span class="n">Xkblock</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Set separating knockoffs = to their features</span>
            <span class="n">sep_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">Xkblock</span><span class="p">[:,</span> <span class="n">sep_inds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">n_inds</span><span class="p">][:,</span> <span class="n">sep_inds</span><span class="p">]</span>
            <span class="n">accblock</span><span class="p">[:,</span> <span class="n">sep_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">probblock</span><span class="p">[:,</span> <span class="n">sep_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Loop through blocks</span>
            <span class="k">for</span> <span class="n">n_inds</span><span class="p">,</span> <span class="n">p_inds</span><span class="p">,</span> <span class="n">sampler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samplers</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="c1"># Sample knockoffs</span>
                <span class="n">Xkblock</span><span class="p">[:,</span> <span class="n">p_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample_knockoffs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># Save final_acc_probs, acceptances</span>
                <span class="n">accblock</span><span class="p">[:,</span> <span class="n">p_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="p">[:,</span> <span class="n">sampler</span><span class="o">.</span><span class="n">inv_order</span><span class="p">]</span>
                <span class="n">probblock</span><span class="p">[:,</span> <span class="n">p_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[:,</span> <span class="n">sampler</span><span class="o">.</span><span class="n">inv_order</span><span class="p">]</span>

            <span class="c1"># Set Xk value for this block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">[</span><span class="n">n_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xkblock</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acceptances</span><span class="p">[</span><span class="n">n_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">accblock</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_acc_probs</span><span class="p">[</span><span class="n">n_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">probblock</span>

        <span class="c1"># Test validity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_xk_validity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span><span class="p">,</span> <span class="n">testname</span><span class="o">=</span><span class="s2">&quot;IsingSampler&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xk</span></div>


    <span class="k">def</span> <span class="nf">_divide_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dc_key</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">max_width</span><span class="p">,</span> <span class="n">div_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes translation, max_width of junction tree, and div_type</span>
<span class="sd">        and returns separator_inds + a list of dictionaries.</span>
<span class="sd">        dc_key is the divconq key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 0. Create separator variables</span>
        <span class="n">separator_inds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="n">max_width</span> <span class="o">==</span> <span class="n">translation</span>
        <span class="p">]</span>
        <span class="n">separator_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">separator_inds</span><span class="p">)</span>
        <span class="n">separator_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">separator_inds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridwidth</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">div_type</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
                    <span class="n">separator_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords2num</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">separator_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords2num</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

        <span class="c1"># 1. Use dgp.num2coords to determine the blocks</span>
        <span class="c1"># that each set of variables appear in (e.g.,</span>
        <span class="c1"># one block is columns 6-10, etc)</span>
        <span class="n">div_groups</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">separator_inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">):</span>
            <span class="c1"># Determine the AC or active coordinate based on</span>
            <span class="c1"># whether or not we are splitting up rows / columns</span>
            <span class="n">ac</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">div_type</span><span class="o">=</span><span class="n">div_type</span><span class="p">)</span>

            <span class="c1"># Ignore this variable if it is a separator</span>
            <span class="k">if</span> <span class="n">ac</span> <span class="ow">in</span> <span class="n">separator_inds</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Groups to the right of lc</span>
            <span class="n">right_groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ac</span> <span class="o">&lt;</span> <span class="n">separator_inds</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">right_groups</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">div_groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">div_groups</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">right_groups</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Remove empty groups</span>
        <span class="n">div_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">div_groups</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Quality check</span>
        <span class="n">num_sep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">separator_vars</span><span class="p">))</span>
        <span class="n">nonsep</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">div_groups</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_sep</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonsep</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Vars do not add to 1 (</span><span class="si">{</span><span class="n">num_sep</span><span class="si">}</span><span class="s2"> separators, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nonsep</span><span class="p">)</span><span class="si">}</span><span class="s2"> non-seps, p=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># 2. Each block is now conditionally indepenent --</span>
        <span class="c1"># see proposition 3 of the paper. We need to change</span>
        <span class="c1"># the cliques to excise the &quot;conditioned-on&quot; variables.</span>
        <span class="c1"># Same thing holds for log-potentials</span>
        <span class="k">def</span> <span class="nf">construct_trunc_logpotent</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">dc_key</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">trunc_lp</span><span class="p">(</span><span class="n">Xj1</span><span class="p">):</span>
                <span class="n">n_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_ninds</span><span class="p">[</span><span class="n">dc_key</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">Xj1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_inds</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Xj1 shape </span><span class="si">{</span><span class="n">Xj1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match num n_inds (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">n_inds</span><span class="p">)</span><span class="si">}</span><span class="s2">) for dc_key=</span><span class="si">{</span><span class="n">dc_key</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">Xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">Xj1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">n_inds</span><span class="p">][:,</span> <span class="n">j2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">lp</span><span class="p">(</span><span class="n">Xc</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">trunc_lp</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">div_group</span> <span class="ow">in</span> <span class="n">div_groups</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;inds&quot;</span><span class="p">:</span> <span class="n">div_group</span><span class="p">})</span>
            <span class="n">div_cliques</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">div_lps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">new_coord_j1</span><span class="p">,</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">div_group</span><span class="p">):</span>
                <span class="c1"># Original cliques for item j</span>
                <span class="n">cliques_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clique_dict</span><span class="p">[</span><span class="n">j1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">clique_key</span><span class="p">,</span> <span class="n">clique</span> <span class="ow">in</span> <span class="n">cliques_j</span><span class="p">:</span>
                    <span class="c1"># Find out which clique member is new</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">clique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">j1</span> <span class="k">else</span> <span class="mi">1</span>
                    <span class="n">j2</span> <span class="o">=</span> <span class="n">clique</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ind</span><span class="p">]</span>
                    <span class="c1"># Coordinates for analysis</span>
                    <span class="n">ac1</span><span class="p">,</span> <span class="n">lc1</span><span class="p">,</span> <span class="n">wc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ac</span><span class="p">(</span><span class="n">j1</span><span class="p">,</span> <span class="n">div_type</span><span class="p">)</span>
                    <span class="n">ac2</span><span class="p">,</span> <span class="n">lc2</span><span class="p">,</span> <span class="n">wc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ac</span><span class="p">(</span><span class="n">j2</span><span class="p">,</span> <span class="n">div_type</span><span class="p">)</span>
                    <span class="c1"># Check if the new clique size is 1 after conditioning</span>
                    <span class="k">if</span> <span class="n">j2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">div_group</span><span class="p">:</span>
                        <span class="c1"># This means j2 must be separating the groups</span>
                        <span class="k">if</span> <span class="n">j2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separator_vars</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;For j1=</span><span class="si">{</span><span class="n">j1</span><span class="si">}</span><span class="s2"> (ac=</span><span class="si">{</span><span class="n">ac1</span><span class="si">}</span><span class="s2">, lc=</span><span class="si">{</span><span class="n">lc1</span><span class="si">}</span><span class="s2">, wc=</span><span class="si">{</span><span class="n">lc2</span><span class="si">}</span><span class="s2">), j2=</span><span class="si">{</span><span class="n">j2</span><span class="si">}</span><span class="s2"> (ac=</span><span class="si">{</span><span class="n">ac2</span><span class="si">}</span><span class="s2">, lc=</span><span class="si">{</span><span class="n">lc2</span><span class="si">}</span><span class="s2">, wc=</span><span class="si">{</span><span class="n">wc2</span><span class="si">}</span><span class="s2">), div_group=</span><span class="si">{</span><span class="n">div_group</span><span class="si">}</span><span class="s2">, separators=</span><span class="si">{</span><span class="n">separator_vars</span><span class="si">}</span><span class="s2">, j2 not a separator&quot;</span>
                            <span class="p">)</span>
                        <span class="c1"># Replace Xj2 with X[:, j2] in log-potential</span>
                        <span class="n">div_cliques</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">new_coord_j1</span><span class="p">])</span>
                        <span class="c1"># This only works because the log potentials are symmetric</span>
                        <span class="c1"># otherwise we&#39;d have to condition on the ind</span>
                        <span class="n">div_lps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">construct_trunc_logpotent</span><span class="p">(</span>
                                <span class="n">lp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span><span class="p">[</span><span class="n">clique_key</span><span class="p">],</span>
                                <span class="n">dc_key</span><span class="o">=</span><span class="n">dc_key</span><span class="p">,</span>
                                <span class="n">j2</span><span class="o">=</span><span class="n">j2</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="c1"># Alternatively, for cliquesize = 2.</span>
                    <span class="c1"># We only append if j1 &lt; j2, to prevent</span>
                    <span class="c1"># double-counting</span>
                    <span class="k">elif</span> <span class="n">j1</span> <span class="o">&gt;=</span> <span class="n">j2</span><span class="p">:</span>
                        <span class="c1"># Find the new coordinate for j2</span>
                        <span class="n">new_coord_j2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">j2</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">div_group</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">div_cliques</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">new_coord_j1</span><span class="p">,</span> <span class="n">new_coord_j2</span><span class="p">])</span>
                        <span class="n">div_lps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_potentials</span><span class="p">[</span><span class="n">clique_key</span><span class="p">])</span>

            <span class="c1"># Add cliques + lps to output</span>
            <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;cliques&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_cliques</span>
            <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;lps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_lps</span>

        <span class="k">return</span> <span class="n">separator_vars</span><span class="p">,</span> <span class="n">output</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Asher Spector.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>